name: Build and Sign LogViewer2026

on:
  push:
    branches: [ master, main ]
    tags:
      - 'v*.*.*'
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '10.0.x'
  PROJECT_PATH: 'LogViewer2026.UI/LogViewer2026.UI.csproj'
  SOLUTION_PATH: 'LogViewer2026.slnx'
  BUILD_CONFIGURATION: 'Release'
  OUTPUT_DIR: '${{ github.workspace }}/publish'

jobs:
  build-and-sign:
    runs-on: windows-latest
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}

    - name: Build solution
      run: dotnet build ${{ env.PROJECT_PATH }} --configuration ${{ env.BUILD_CONFIGURATION }} --no-restore

    - name: Run tests
      run: dotnet test ${{ env.PROJECT_PATH }} --configuration ${{ env.BUILD_CONFIGURATION }} --no-build --verbosity normal
      continue-on-error: true
    
    - name: Publish application
      shell: pwsh
      run: |
        dotnet publish ${{ env.PROJECT_PATH }} `
          --configuration ${{ env.BUILD_CONFIGURATION }} `
          --output ${{ env.OUTPUT_DIR }} `
          --runtime win-x64 `
          --self-contained true `
          -p:PublishSingleFile=true `
          -p:PublishReadyToRun=true
    
    - name: Get version
      id: get_version
      shell: pwsh
      run: |
        if ($env:GITHUB_REF -match 'refs/tags/v(.*)') {
          $version = $matches[1]
        } else {
          $version = "1.0.0-dev.$($env:GITHUB_RUN_NUMBER)"
        }
        # Compute a normalised Windows output path and expose it for all later steps
        $outputDir = Join-Path $env:GITHUB_WORKSPACE "publish"
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        echo "OUTPUT_DIR=$outputDir" >> $env:GITHUB_ENV
        Write-Host "Version : $version"
        Write-Host "OutputDir: $outputDir"
    
    # Code Signing using certificate from secrets
    - name: Decode certificate
      if: false  # TEMPORARILY DISABLED
      shell: pwsh
      run: |
        $certificateBytes = [System.Convert]::FromBase64String("${{ secrets.SIGNING_CERTIFICATE_BASE64 }}")
        $certificatePath = Join-Path $env:GITHUB_WORKSPACE "certificate.pfx"
        [IO.File]::WriteAllBytes($certificatePath, $certificateBytes)
        echo "CERTIFICATE_PATH=$certificatePath" >> $env:GITHUB_ENV
    
    - name: Sign executable
      if: false  # TEMPORARILY DISABLED
      shell: pwsh
      run: |
        # Validate secrets
        if ([string]::IsNullOrWhiteSpace("${{ secrets.SIGNING_CERTIFICATE_PASSWORD }}")) {
          Write-Error "SIGNING_CERTIFICATE_PASSWORD secret is not set or is empty!"
          Write-Host "Please add the secret in GitHub: https://github.com/${{ github.repository }}/settings/secrets/actions"
          exit 1
        }

        if ([string]::IsNullOrWhiteSpace("${{ secrets.SIGNING_CERTIFICATE_BASE64 }}")) {
          Write-Error "SIGNING_CERTIFICATE_BASE64 secret is not set or is empty!"
          Write-Host "Please add the secret in GitHub: https://github.com/${{ github.repository }}/settings/secrets/actions"
          exit 1
        }

        $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"

        # Find the most recent signtool if the above path doesn't exist
        if (-not (Test-Path $signtool)) {
          $signtool = Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin\" -Recurse -Filter "signtool.exe" | 
            Where-Object { $_.FullName -like "*\x64\*" } | 
            Sort-Object FullName -Descending | 
            Select-Object -First 1 -ExpandProperty FullName
        }

        if (-not (Test-Path $signtool)) {
          Write-Error "SignTool not found"
          exit 1
        }

        Write-Host "Using SignTool: $signtool"

        $exePath = Join-Path "${{ env.OUTPUT_DIR }}" "LogViewer2026.UI.exe"

        if (-not (Test-Path $exePath)) {
          Write-Error "Executable not found at: $exePath"
          exit 1
        }

        Write-Host "Signing: $exePath"

        # Import certificate to store
        try {
          $passwordString = "${{ secrets.SIGNING_CERTIFICATE_PASSWORD }}"

          if ([string]::IsNullOrWhiteSpace($passwordString)) {
            throw "Certificate password is empty"
          }

          Write-Host "Converting password to SecureString..."
          $password = ConvertTo-SecureString -String $passwordString -AsPlainText -Force

          Write-Host "Importing certificate from: ${{ env.CERTIFICATE_PATH }}"
          $cert = Import-PfxCertificate -FilePath "${{ env.CERTIFICATE_PATH }}" -CertStoreLocation Cert:\CurrentUser\My -Password $password
          Write-Host "Certificate imported with thumbprint: $($cert.Thumbprint)"

          # Sign using certificate from store
          Write-Host "Signing executable with certificate..."
          & $signtool sign `
            /sha1 $cert.Thumbprint `
            /tr http://timestamp.digicert.com `
            /td sha256 `
            /fd sha256 `
            /d "LogViewer2026 - High-Performance Serilog Log Viewer" `
            /du "https://github.com/${{ github.repository }}" `
            "$exePath"

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Signing failed with exit code: $LASTEXITCODE"
            exit $LASTEXITCODE
          }

          Write-Host "Successfully signed executable"

          # Verify signature (non-fatal for self-signed certificates)
          Write-Host "Verifying signature..."
          & $signtool verify /pa "$exePath" 2>&1 | Out-String | Write-Host

          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Signature verification failed - this is expected for self-signed certificates"
            Write-Host "The executable is signed, but the certificate chain is not trusted."
            Write-Host "For production use, obtain a certificate from a trusted CA."
          } else {
            Write-Host "Signature verified successfully" -ForegroundColor Green
          }

          # Clean up certificate from store
          Remove-Item -Path "Cert:\CurrentUser\My\$($cert.Thumbprint)" -Force
          Write-Host "Certificate removed from store"
        }
        catch {
          Write-Error "Error during signing process: $_"
          exit 1
        }
    
    - name: Remove certificate
      if: false  # TEMPORARILY DISABLED
      shell: pwsh
      run: |
        if ($env:CERTIFICATE_PATH -and (Test-Path $env:CERTIFICATE_PATH)) {
          Remove-Item $env:CERTIFICATE_PATH -Force
          Write-Host "Certificate file removed"
        }
    
    - name: Create ZIP archive
      shell: pwsh
      run: |
        $archiveName = "LogViewer2026-v${{ steps.get_version.outputs.VERSION }}-windows.zip"
        $archivePath = Join-Path $env:GITHUB_WORKSPACE $archiveName
        Write-Host "Compressing: $env:OUTPUT_DIR  ->  $archivePath"
        Compress-Archive -Path "$env:OUTPUT_DIR\*" -DestinationPath $archivePath
        if (-not (Test-Path $archivePath)) {
          Write-Error "Archive was not created at: $archivePath"
          exit 1
        }
        Write-Host "Archive created: $archivePath  ($([math]::Round((Get-Item $archivePath).Length / 1MB, 2)) MB)"
        echo "ARCHIVE_NAME=$archiveName" >> $env:GITHUB_ENV
        echo "ARCHIVE_PATH=$archivePath" >> $env:GITHUB_ENV
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: LogViewer2026-v${{ steps.get_version.outputs.VERSION }}
        path: ${{ env.OUTPUT_DIR }}
        retention-days: 30
    
    - name: Upload ZIP artifact
      uses: actions/upload-artifact@v4
      with:
        name: LogViewer2026-v${{ steps.get_version.outputs.VERSION }}-zip
        path: ${{ env.ARCHIVE_PATH }}
        retention-days: 90
    
    # Create GitHub Release for tags
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/v')
      uses: softprops/action-gh-release@v1
      with:
        files: ${{ env.ARCHIVE_PATH }}
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
